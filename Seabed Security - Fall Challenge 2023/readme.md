-----------------------------Правила игры ------------------------------
В данной игре выигрывает игрок, который отсканирует наибольшее количество рыб.
Игра пошаговая и в ней необходимо перемещать по 2D полю и освещать рыб в радиусе действия освещения корабля. Радиус можно увеличивать, но это будет затрачивать больше энергии, которую необходимо беречь, т.к. она является главным ограничением.
За сканирование рыб с одинаковым признаком начисляются бонусные баллы.
За ход дрон может перемещаться на 600 единиц, если он не перемещается, то падает на 300 ед.
Ёмкость батареи составляет 30 условных единиц.
В конце каждого хода фонарь освещает пространство в некотором радиусе. При этом, если освещается  радиус 2000 ед., то затрачивается 5 ед. энергии.

Карта:
Карта представляет собой квадрат со стороной 10 000 единиц. В остальной части описания единицы измерения длины будут обозначаться как «u». Координата (0, 0) находится в верхнем левом углу карты.

Условия победы:
Игра длится 200 ходов
Игрок набрал достаточно очков, чтобы его соперник не смог его догнать
Оба игрока сохранили сканы всех оставшихся рыб на карте

Условия поражения:
Ваша программа не отвечает в течение заданного времени или выдает нераспознанную команду.


----------------------Что было реализовано-----------------------------------

Для фиксации состояния игры и упрощённой работы:
- Созданы структуры для хранения информации о рыбах, дронах и состоянии игры
- Реализован класс Game для более удобной работы
- Код дописан, чтобы фиксировать то, какие рыбки уже отсканированы и как изменяются их координаты.
Приоритет сканирования фиксируется через с map-ы
(map<int, int> type_priority = {{0, 1}, {1, 2}, {2, 3}};)

- Алгоритм выбора целей: В первую очередь проверяет видимые неотсканированные рыбы, а оценивает к какой рыбе нужно плыть (score = priority * 1000 / (distance + 1))
Также нужно учитывать следующие соображения:
Тип 2: 3 очка (6 за первое сканирование) - Соответственно, это наивыгоднейшее решение
Тип 1: 2 очка (4 за первое) - средняя результативность
Тип 0: 1 очко (2 за первое) - низший приоритет

- Управление плаванием осуществлется с помощью структуры Point calculate_move_towards(const Point& from, const Point& to, int max_distance)
Которая должна учитывать границы карты и 

- Работа с фонарём учитывает следующие пераметры:
    - Свет включается только при наличии целей на расстоянии >500u
    - Батарея перезаряжается когда свет выключен
    - Защита от полной разрядки (батарея >3 отн. ед.)

- Стратегия исследования
Верхние слои (y < 2500): горизонтальное движение для широкого охвата
Глубокие слои (y ≥ 2500): движение к поверхности с параллельным сканированием
Отсутствие видимых целей: систематическое сканирование секторов


----------Решённые проблемы--------------------------------------

1. Ограниченная видимость
Рыбы видны только когда находятся достаточно близко к дрону

Решение:
Использование данных радара для предварительного позиционирования
Стратегическое патрулирование областей с высокой вероятностью нахождения рыб

2. Конкуренция с противником
Проблема: Противник также сканирует рыб, создавая конкуренцию за ценные цели
Решение:
Приоритетное сканирование рыб высокого типа
Быстрое реагирование на появление видимых ценных рыб

3. Ограничения движения
Проблема: Максимум 600u за ход или 300u погружение при бездействии
Решение:
Предварительное планирование траектории
Упреждающее движение к перспективным областям
Управление границами осущствляется следующим кодом:
if (move_to.x <= 100) move_to.x = 1000;
if (move_to.x >= 9900) move_to.x = 9000;

4. Множественность целей
Проблема: Одновременное наличие нескольких потенциальных целей
Решение:
Функция оценки целей с линейной зависимостью от приоритета типа и гиперболической зависимостью от расстояния:
double score = game.type_priority[type]/ (dist + 1);



Таким образом была получена рабочая реализация программы

